#! /usr/bin/env python
# -*- coding: utf-8 -*-

import sys
import getopt
import requests
import time
from wave import open as waveOpen
from ossaudiodev import open as ossOpen

#klasa Ticker pobiera dane z serwera i wyświetla je w konsoli
class Ticker(object):
	def __init__(self):
		self.data = ()
	def get(self, url, user_timeout = 30):
		#try:
			self.data = requests.get(url, timeout = user_timeout).json()
		#except:
			print "Błąd: Brak połączenia z serwerem !!!"
		#else:	
			return self.data
	

#klasa Audio obsługuje pliki wav i odtwarza je
class Audio(object):
	def play(self, wav_file):
		try:
			stream = waveOpen(wav_file,'rb')
			(nc,sw,fr,nf,comptype, compname) = stream.getparams()
			dsp_device = ossOpen('/dev/dsp','w')
			try:
				from ossaudiodev import AFMT_S16_NE
			except ImportError:
				if byteorder == "little":
					AFMT_S16_NE = ossaudiodev.AFMT_S16_LE
				else:
					AFMT_S16_NE = ossaudiodev.AFMT_S16_BE
			dsp_device.setparameters(AFMT_S16_NE, nc, fr)
			data = stream.readframes(nf)
			stream.close()
			dsp_device.write(data)
			dsp_device.close()
		except:
			print "Błąd: Wystąpił problem podczas odtwarzania pliku audio !!!"

#klasa Broker
#porównuje bierzący kurs z poziomami alarmowymi kursu
class Broker(object):
	def __init__(self, min_alert, max_alert, sound = 1, sleep_t = 30, wav_min = 'Buzzer.wav', wav_max = 'ComputerMagic.wav'):
		self.ticker = Ticker()
		self.audio = Audio()
		self.wav_min = wav_min
		self.wav_max = wav_max
		self.max_flag = 0
		self.min_flag = 0
		self.counter = 0
		self.sound = sound
		
		if sleep_t >= 0:
			self.sleep_time = sleep_t
		else:
			raise Exception, "Błąd: Niepoprawny czas uśpienia !!!"
		if min_alert < max_alert: 
			self.min_price_alert = min_alert
			self.max_price_alert = max_alert
		else:
			raise Exception, "Błąd: Błędne wartości poziomów alarmowych kursu !!!"
		
	def check_price(self):
		self.ticker.get()
		self.ticker.show()
		try:
			if self.ticker.data['last'] > self.max_price_alert:
				print "Alarm !!! Przekroczono cenę maksymalną !!!"
				if self.max_flag == 0 :
					if self.sound: self.audio.play(self.wav_max)
					self.max_flag = 1
			elif self.ticker.data['last'] < self.min_price_alert:
				print "Alarm !!! Przekroczono cenę minimalną !!!"
				if self.min_flag == 0:
					if self.sound: self.audio.play(self.wav_min)
					self.min_flag = 1
			else:
				self.max_flag = 0
				self.min_flag = 0
		except:
			print "Błąd: Brak danych !!!"
		self.counter += 1
		if self.counter >= 10:
			self.counter = 0
			self.max_flag = 0
			self.min_flag = 0
		time.sleep(self.sleep_time)	#pętla wykonuje się co sleep_time sekund

	
#program główny
if __name__ == "__main__":
	main()


